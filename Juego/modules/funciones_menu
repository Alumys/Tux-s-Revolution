import pygame 
# Así es como debe verse la importación COMPLETA:
from modules.dimensiones_de_ventana import (
    ANCHO_PANTALLA, ALTO_PANTALLA, CENTRO_X, INICIO_Y, ESPACIADO, 
    ANCHO_BOTON, ALTO_BOTON, BLANCO, NEGRO, AZUL_MENU, AMARILLO, GRIS_PANEL
)

pantalla = pygame.display.set_mode((ANCHO_PANTALLA, ALTO_PANTALLA))
pygame.display.set_caption("Menu de Tux Revolution (Diamante)")
fuente_titulo = pygame.font.Font(None, 80)
fuente_opciones = pygame.font.Font(None, 40)

# FUNCIÓN DE ACCIÓN CENTRAL (MODIFICADA)
def manejar_acciones_boton(indice):
    """
    Maneja las acciones basadas en el índice del botón pulsado.
    Ahora devuelve False si se debe salir, True en caso contrario.
    """
    match indice:
        case 0: print(">>> Iniciando el juego principal..."); return True
        case 1: print(">>> Conectando al lobby..."); return True
        case 2: print(">>> Mostrando puntuaciones altas..."); return True
        case 3: print(">>> Abriendo opciones..."); return True
        case 4: print(">>> Mostrando los créditos..."); return True
        case 5: return False # Devuelve False para indicar salida

# DATOS DEL MENÚ Y POSICIONES
textos_botones = ["JUGAR", "MULTIJUGADOR", "PUNTUACIÓN", "OPCIONES DE JUEGO", "CRÉDITOS", "SALIR"]
# Almacenamos los puntos del polígono, el Rect para colisiones y la posición Y del texto
botones_data = []

for i, texto in enumerate(textos_botones):
    pos_y_centro = INICIO_Y + i * ESPACIADO + (20 if texto == "SALIR" else 0)

    # Calcular los 4 vértices del diamante
    puntos_diamante = [
        (CENTRO_X, pos_y_centro - ALTO_BOTON // 2),
        (CENTRO_X + ANCHO_BOTON // 2, pos_y_centro),
        (CENTRO_X, pos_y_centro + ALTO_BOTON // 2),
        (CENTRO_X - ANCHO_BOTON // 2, pos_y_centro)
    ]

    rect_colision = pygame.Rect(CENTRO_X - ANCHO_BOTON // 2, pos_y_centro - ALTO_BOTON // 2, ANCHO_BOTON, ALTO_BOTON)

    botones_data.append({"puntos": puntos_diamante, "centro_y": pos_y_centro, "rect": rect_colision})

# Título
texto_titulo = fuente_titulo.render("TUX REVOLUTION", True, NEGRO)
rect_titulo = texto_titulo.get_rect(center=(CENTRO_X, 100))

# BUCLE PRINCIPAL (MODIFICADO para capturar el retorno)
bucle_principal = True
while bucle_principal:
    posicion_mouse = pygame.mouse.get_pos()

    for evento in pygame.event.get():
        if evento.type == pygame.QUIT:
            bucle_principal = False
        if evento.type == pygame.MOUSEBUTTONDOWN:
            for i, data in enumerate(botones_data):
                if data["rect"].collidepoint(evento.pos):
                    # Capturamos el resultado de la función
                    debe_continuar = manejar_acciones_boton(i)
                    if not debe_continuar:
                        bucle_principal = False # Actualizamos la variable local del bucle

    pantalla.fill(BLANCO)

    # Dibujamos el panel de fondo
    panel_surface = pygame.Surface((ANCHO_PANTALLA, ALTO_PANTALLA), pygame.SRCALPHA)
    pygame.draw.rect(panel_surface, GRIS_PANEL, panel_surface.get_rect(), border_radius=50)
    pantalla.blit(panel_surface, (0, 0))

    pantalla.blit(texto_titulo, rect_titulo)

    # Dibujado de botones (diamantes)
    for i, data in enumerate(botones_data):

        if data["rect"].collidepoint(posicion_mouse):
             color = AMARILLO
        else:
             color = AZUL_MENU

        # Dibujamos la forma de polígono (diamante) visualmente
        pygame.draw.polygon(pantalla, color, data["puntos"])

        # Renderizamos el texto
        superficie_texto = fuente_opciones.render(textos_botones[i], True, NEGRO)
        rect_texto = superficie_texto.get_rect(center=(CENTRO_X, data["centro_y"]))
        pantalla.blit(superficie_texto, rect_texto)

    pygame.display.flip()

